# 模块化

## 一. 认识模块化

> 模块化就是一种约定，一种规范；
>
> 场景模拟：小强，小黄，小刚 共同基于 Node.js 开发项目！

1. 为什么要有模块化：**为了解决文件之间的依赖关系**；
2. 注意：**模块化是一种开发思想**；具体开发中需要定制符合实际需求的**模块化规范**！
3. 大家可以把模块化规范，认为是一种**明文的约定**，大家都按照相同的约定写代码，减少了不必要的沟通成本，极大方便了各个模块之间的调用，方便别人，同时也方便自己；



## 二. 了解CommonJs规范

1. 作用：是一套 Javascript 的模块化规范，规定了 **模块的特性** 和 **各模块之间如何相互依赖**；
2. 用途：Node.js 中使用了 CommonJS 规范；
3. 特点：**同步加载模块；** 不适合在浏览器端使用；
4. CommonJS规范都定义了哪些内容：[wiki 对于 Modules 的描述](http://wiki.commonjs.org/wiki/Modules/1.1)

## 三. 模块作用域 和 全局作用域

> 在Node.js中有两个作用域，分别是 全局作用域 和 模块作用域；

1. 全局作用域使用 `global` 来访问，类似于`浏览器中的window`；
2. 每个 Javascript 文件，都是一个单独模块，每个模块都有自己独立的作用域，因此：模块中的成员，默认无法被其它模块访问。



### 3.1 使用 global 全局作用域在模块之间共享成员

1. 如果在某个模块内部，想为 全局的 global 作用域挂载一些属性，需要显示的调用`global.***`来挂载；
2. 注意：在开发中，一般情况下，不推荐使用`global`全局作用域来共享成员，会存在全局变量污染问题；



### 3.2 模块作用域

1. **module（模块标识）**

   module 属性是 Common JS 规范中定义的，它是一个对象，表示当前这个具体的 js 模块；

2. **require（引用模块）**

   每一个实现了 CommonJS 规范的模块，必须定义一个 require() 函数，使用这个 require 函数，就能够 很方便的导入其它 模块中的成员，供自己使用；

3. **exports（暴露模块成员）**

   每一个模块中，如果想要把自己的一些私有成员，暴露给别人使用，那么，必须实现一个 exports 对象，通过exports对象，可以方便的把模块内私有的成员，暴露给外界使用；



### 3.3 module.exports 和 exports 的关系

1. `module.exports` 和 `exports` 默认引用了同一个空对象；
2. `module.exports` 和 `exports` 作用一致，都可以向外暴露成员；
3. 一个模块作用域中，向外暴露私有成员时，永远以 `module.exports` 为准；



## 四. 了解 - 浏览器端的 AMD 和 CMD 模块化规范

> 注意：浏览器端不能使用 CommonJS规范；因为 CommonJS 下，模块是同步加载的；

> AMD/CMD可以理解为是commonjs在浏览器端的解决方案，AMD/CMD下，模块都是异步加载的；

1. AMD模块化规范代表：RequireJS
   - 主要特性1：对于依赖的模块，AMD 是提前执行；
   - 主要特性2：推崇**依赖前置**；
2. CMD模块化规范代表：SeaJS
   - 主要特性1：对于依赖的模块，CMD 是延迟执行；CMD 推崇 as lazy as possible.
   - 主要特性2：推崇**依赖就近**；
3. ES6的模块化（**大趋势**）：es6是在**语言标准层面上**，实现了模块功能，而且实现得相当简单，**完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案**；



## 五. nodeJs中的模块和包的概念

### 5.1 模块

#### 模块分类

	模块成员，根据一些区别，又可以分为三大类： 核心模块、第三方模块、用户自定义模块



#### 核心模块

1. **什么是核心模块：**
   - 随着Node.js的安装包，一同安装到本地的模块，叫做核心模块；
   - 例如：`fs`，`path`等模块，都是由Node.js官方提供的核心模块；
   - 只要大家在计算机中，安装了Node这个应用程序，那么，我们的计算机中就已经安装了所有的 核心模块；
2. **如何使用核心模块**：`require('核心模块标识符')`



#### 第三方模块

1. **什么是第三方模块：**
   - 一些非官方提供的模块，叫做第三方模块；
   - 注意，第三方模块，并不在我们的计算机上；
   - 如果大家需要使用某些第三方模块，必须去一个叫做 `NPM` 的网站上搜索并下载才能使用；
2. **如何使用第三方模块：**
   - 先从 npm 官网上下载指定的第三方模块
   - 使用 `require('第三方模块的名称标识符')`来导入这个模块
   - 根据 第三方模块的 官方文档，尝试使用



#### 自定义模块

1. **什么是用户模块：**
   - 程序员在自己项目中写的 Javascript 文件，就叫做 用户自定义模块；
2. **如何使用用户模块：**`require('路径标识符')`



###5.2 包

#### 5.2.1 什么是包

1. 英文名叫做 `Packages`，包是在模块基础上更深一步的抽象；
2. 包的目的：方便分发和推广基于 CommonJS 规范实现的 应用程序 或 类库；
3. 包可以看作是 **模块**、**代码** 和 **其它资源** 组合起来形成的 独立作用域；



#### 5.2.2 包的规范结构

1. **包都要以一个单独的目录而存在**；
2. **`package.json` 必须在包的顶层目录下**；
3. **`package.json` 文件必须符合 JSON 格式，并且必须包含如下三个属性：`name`, `version`, `main`**
   - **name**:  包的名字
   - **version**: 包的版本号
   - **main**: 表示包的入口文件
4. 二进制文件应该在**bin目录**下;
5. javaScript代码应该在**lib目录**下;
6. 文档应该在**doc目录**下;
7. 单元测试应该在**test目录**下;
8. Node.js对包要求并没有那么严格，只要顶层目录下有`package.json`，并**符合基本规范**即可;



#### 5.3.3 包描述文件package.json

```
name：包的名称，必须是唯一
description：包的简要说明
version：符合语义化版本识别规范的版本字符串
keywords：关键字数据，通常用于搜索
maintainers：维护者数组，每个元素要包含name、email、web可选字段
contributors：贡献者数组，格式与maintainers相同。包的坐着应该是贡献者数据的第一个元素
bugs：提交bug的地址，可以是网址或者电子邮件地址
licenses：许可证数组，每个元素要包含type和url字段
repositories：仓库托管地址数组，每个元素要包含type、url和path字段
dependencies：包的依赖，一个关联数组，由包名称和版本号组成。
devDependencies：开发依赖项，表示一个包在开发期间用到的依赖项
```

#### 案例：自己封装一个包含 加减乘除 的包



## 六 npm

### 6.1 npm的两层含义

1. NPM 是一个 第三方模块的托管网站，指的就是`https://www.npmjs.com/`；
2. NPM 是Node的包管理工具（全名叫做  Node package manager），在我们安装Node时候，就已经顺便也安装了 NPM 这个管理工具；

### 6.2 安装和卸载全局包

1. **什么是全局的包：**安装到计算机全局环境中的包，叫做全局包；安装的全局包可以在当前电脑的任何目录下，直接通过命令行来访问；
2. **如何安装全局包：**运行 `npm install 包名 -g` 即可；其中 `-g` 参数，表示 把包安装到全局目录中的意思；
3. **全局包的安装目录：**`C:\Users\用户目录\AppData\Roaming\npm`
4. **什么样的包适合安装到全局：**工具性质的包，适合安装到全局；
5. **如何卸载全局包：**要卸载某个全局的包，直接运行`npm uninstall 包名 -g`即可；其中 `uninstall` 表示卸载的意思；
6. **npm遇到write access的问题怎么办？**
   + 参考：[解决方案](https://www.jianshu.com/p/31744aa44824)



### 6.3 安装和卸载本地包

1. **什么是本地的包：**跟着项目安装的包，叫做本地包；本地包都会被安装到 node_modules 目录下；
2. **注意：**如果拿到一个空项目，**必须**在当前项目根目录中，先运行 `npm init`或者`npm init -y` 命令，初始化一个`package.json`的配置文件，否则包无法安装到本地项目中；
3. **如何安装本地包：**运行`npm i 包名 --save` 即可安装本地包；都安装到了当前项目的 `node_modules`目录下；
   - 如果大家用的是npm 5.x的版本，可以不指定`--save`命令，如果用的是 npm 3.x 的版本，则需要手动指定 `--save`；
4. `package-lock.json`文件中记录了曾经装过的包的下载地址，方便下次直接下载包，能够加快装包的速度，提升装包的体验；
5. **如何卸载本地包：**使用 `npm uninstall/remove 包名 -S/-D`即可卸载指定的本地包；



### 6.4 其他常用命令

1. `--save` 的缩写是 `-S`
2. `--save-dev`的缩写是 `-D`
3. `install` 的缩写是 `i`
4. 注意：`dependencies` 节点，表示项目上线部署时候需要的依赖项；`devDependencies`节点，表示项目在开发阶段需要的依赖项，但是当项目要部署上线了，`devDependencies`节点中的包，就不再需要了！
5. 注意：当使用 `npm i`快速装包的时候，npm会检查`package.json`文件中，所有的依赖项，然后都为我们安装到项目中
6. `--production` 表示只安装 `dependencies` 节点下，记录的包，不安装`devDependencies`节点下的包；当项目要上线了，才会使用`--production`命令



## 七. 模块加载机制

### 优先从缓存中加载

- 当一个模块初次被 `require` 的时候，会执行模块中的代码，当第二次加载相同模块的时候，会优先从缓存中查找，看有没有这样的一个模块！
- 好处：提高模块的加载速度；不需要每次都重新执行并加载模块！

### 核心模块的加载机制

- 先查找缓存；如果缓存中没有，再去加载核心模块；

### 用户模块的加载机制

- 先查找缓存；

- 如果缓存中没有则尝试加载用户模块；

- 如果在加载用户模块时候省略了后缀名，则：

  ```
  首先，严格按照指定的名称去查找
  其次，尝试加载后缀名是 .js 的文件
  如果没有.js的文件，则尝试加载 .json 结尾的文件
  如果没有 .json 的文件，则尝试加载 .node 结尾的文件
  查找规则：index  ->  index.js   ->   index.json   ->  index.node
  ```

### 第三方模块的加载机制【了解】

1. 先在项目根目录中查找`node_modules`文件夹
2. 在`node_modules`文件夹下，查找模块相关的文件夹
3. 在对应的文件夹下，查找`package.json`的文件
4. 查找`package.json`文件中的`main`属性（指定了模块的入口文件）
5. 如果找到了`main`属性，同时，`main`属性指定的文件路径存在，那么尝试加载指定的文件模块
6. 加入没有`main`属性，或者`main`属性对应的文件不存在，或者没有`package.json`,那么会依次尝试加载`index.js`，`index.json`,`index.node`;
7. 如果没有`index`相关的文件，或者没有指定模块对应文件夹，或者，当前项目根目录中没有`node_modules`文件夹，则向上一层目录中查找`node_modules`，查找规则同上！
8. 最后，如果在项目所在磁盘的盘符根目录中，还找不到对应模块，则报错：`cannot find module ***`



## 



